#!/usr/bin/env python

import errno
import os
import os.path
import sys
import time

from driller import Driller


def save_driller_output(output, dest, identifier):
    """
    This function saves the output generated by DrillerPrime for the seed input provided by AFL.
    The output file is saved into the 'dest' directory and is named: id:#####, drillerPrime.
    The number followed the 'id:' literal represents the output number.
    Written output file will be used as input by AFL.
    """
    with open(os.path.join(dest, 'id:%05d,drillerPrime' % identifier), 'wb') as drillerPrime_output_file:
        drillerPrime_output_file.write(output)


def main():
    # Ensure proper number arguments are given
    if len(sys.argv) < 3:
        print('Usage: %s <binary> <AFL_output_dir>' % os.path.basename(sys.argv[0]))
        sys.exit(1)
    # Unpacking system arguments and initializing optional arguments
    input_growth = None
    depth_limit = None
    heuristic = None
    if(len(sys.argv) == 3):
        _, binary, afl_output_dir = sys.argv
    elif(len(sys.argv) == 4):
        _, binary, afl_output_dir, input_growth = sys.argv
    elif(len(sys.argv) == 5):
        _, binary, afl_output_dir, input_growth, depth_limit = sys.argv
    elif(len(sys.argv) == 6):
        _, binary, afl_output_dir, input_growth, depth_limit, heuristic = sys.argv
    else:
        print("Expected 6 arguments but given", len(sys.argv))
        sys.exit(1)

    # Read AFL bitmap and configure output/input directories
    with open(os.path.join(afl_output_dir, 'fuzz_bitmap'), 'rb') as bitmap:
        afl_bitmap = bitmap.read()
    afl_queue_dir = os.path.join(afl_output_dir, 'queue')
    driller_prime_queue_dir = os.path.join(afl_output_dir, '..', 'drillerPrime', 'queue')

    # Create queue folder for drillerPrime and ensure completion
    try:
        os.makedirs(driller_prime_queue_dir)
    except os.error as err:
        if err.errno != errno.EEXIST:
            raise

    # Initialize set containing AFL input that's already been drilled by DrillerPrime
    drilled = set()
    # Used to identify the output generated by DrillerPrime when calling the save function
    output_identifier = len(os.listdir(driller_prime_queue_dir))

    # Iterate through AFL's queue to continuously drill new inputs
    while True:
        # Ensure that input hasn't been seen and add to 'drilled' set
        for input_name in os.listdir(afl_queue_dir):
            if input_name in drilled or not input_name.startswith('id:'):
                continue
            drilled.add(input_name)
            # Read AFL input and pass to DrillerPrime
            with open(os.path.join(afl_queue_dir, input_name), 'rb') as afl_input_file:
                afl_input = afl_input_file.read()

            print('Drilling input: %s' % afl_input)
            print('Input file: %s' % os.path.basename(os.path.join(afl_queue_dir, input_name)))
            for _, drilled_output in Driller(binary, afl_input, afl_bitmap, input_growth=input_growth, depth_limit=depth_limit, heuristic=heuristic).drill_generator():
                save_driller_output(drilled_output, driller_prime_queue_dir, output_identifier)
                output_identifier += 1

        # Sleep if there are no new inputs generated by AFL
        time.sleep(len(os.listdir(afl_queue_dir)) / 2 if len(os.listdir(afl_queue_dir)) / 2 else 100)


if __name__ == '__main__':
    main()
