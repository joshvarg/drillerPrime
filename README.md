## Driller

Driller is an implementation of the [driller paper](https://www.cs.ucsb.edu/~vigna/publications/2016_NDSS_Driller.pdf). This implementation was built on top of AFL with angr being used as a symbolic tracer. Driller selectively traces inputs generated by AFL when AFL stops reporting any paths as 'favorites'. Driller will take all untraced paths which exist in AFL's queue and look for basic block transitions AFL failed to find satisfying inputs for. Driller will then use angr to synthesize inputs for these basic block transitions and present it to AFL for syncing. From here, AFL can determine if any paths generated by Driller are interesting, it will then go ahead and mutate these as normal in an attempt to find more paths.

### The "Stuck" heuristic

Driller's symbolic execution component is invoked when AFL is 'stuck'. 
In this implementation, AFL's progress is determined by its 'pending\_favs' attribute which can found in the fuzzer\_stats file. 
When this attribute reaches 0, Driller is invoked. Other heuristics could also be used, and it's infact likely that better heuristics exist.

### Use in the Cyber Grand Challenge

This same implementation of Driller was used team Shellphish in DARPA's Cyber Grand Challenge (CGC) to aid in the discovery of exploitable bugs.
To see how Driller's invokation was scheduled for the CGC you can look at the Mechanical Phish's scheduler component 'meister'.

### Current State and Caveats

The code currently supports three modes of operation:

+ A script that facilitates AFL and driller on one machine (over many cores if needed): https://github.com/shellphish/fuzzer/blob/master/shellphuzz
+ A monitor process watches over the fuzzer\_stats file to determine when Driller should be invoked. When Driller looks like it could be useful, the monitor process schedules 'jobs' to work over all the inputs AFL has discovered / deemed interesting.
+ Celery tasks are assigned over a fleet of machines, some number of these tasks are assigned to fuzzing, some are assigned to drilling. Fuzzer tasks monitors the stats file, and invokes driller tasks when Driller looks like it could be useful. Redis is used to sync testcases to the filesystem of the fuzzer.

Driller was built and developed for DECREE binaries.
While some support for other formats should work out-of-the-box, expect `TracerMisfollowError`s to occur when unsupported or incorrectly implemented simprocedures are hit.

### Example

Here is an example of using driller to find new testcases based off the trace of a single testcase.

```python
import driller

d = driller.Driller("./CADET_00001",  # path to the target binary
                    "racecar", # initial testcase
                    "\xff" * 65535, # AFL bitmap with no discovered transitions
                   )

new_inputs = d.drill()
```

### DrillerPrime Tutorial
First, we must install the shellphish docker container, and install docker.
  sudo apt install docker
  docker pull shellphish/mechaphish
 Then, we can enter the container
  docker run -it shellphish/mechaphish bash
 This should put you into the docker container used to run DrillerPrime, and you should see (angr) prior to the container name.
 Next, we can install AFL
  sudo apt install AFL
  cd AFL
  make
 and then enable QEMU mode
  cd qemu_mode
  ./build-qemu-support.sh
  cd
 Note here that there may be an error with python. In this case, you need to edit the build-qemu-support.sh file to point to the correct Python version in the ./configure command contained in the file, in my case it was /usr/bin/python3, so I added the option --python=/usr/bin/python3.
 After that, QEMU support for AFL should be built. We are now ready to install DrillerPrime
  git clone https://github.com/joshvarg/drillerPrime
  cd drillerPrime
  cd test_src
  cd png
 This is the location of the test binary, you may choose to compile it with or without AFL instrumentation, keep in mind that DrillerPrime will not work with AFL's instrumentation. So, here is the command to compile the test without that:
 
  gcc -o test test.c upng.c lodepng.c upng_decoder_test.c lodepng_decoder_test.c
  cd
  
 This should create the test binary for us to use. Now we want to set up our inputs folder.
 
  cd drillerPrime
  mkdir inputs
  mv test_src/s-min.png inputs
  cd
  
 We are now ready to run AFL, and then DrillerPrime after! To run both at the same time, I would recommend the tmux tool, or opening up a second terminal window and entering the docker container on that as well. Here is the command to start AFL:
 
  AFL/afl-fuzz -M fuzzer-master -i drillerPrime/inputs -o drillerPrime/outputs -Q drillerPrime/test_src/png/test
  
Make sure to add the -Q option, because that is what leverages QEMU mode. AFL will throw an error if that flag is not set. Now, we are ready to run the following command in a different terminal window to get DrillerPrime running:

 cd drillerPrime
 python3 driller_prime.py test_src/png/test outputs/fuzzer-master
 
This command will allow DrillerPrime to access AFL's input queue, and help it by generating test cases. It is now ready to go, and can be left running until you decide to stop both programs. Keep in mind that this was only one example of using DrillerPrime, using the test harness we created to compare upng and lodepng. Enjoy!

#### Dependencies

+ Mechaphish Fuzzer component
+ Mechaphish Tracer component
